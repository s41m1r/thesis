\subsection{Related Work}
\label{subsec:related}
A solution addressing these requirements can partially build upon research in three main areas:
\begin{inparaenum}[\itshape i)]
	\item work on \gls{msr};
	\item \gls{pm};
	\item and software visualization.
\end{inparaenum}

\input{bpm2017/tables/related-work-table}

Table~\ref{table:related-work} shows that these streams of research have mutual strengths, but no contribution covers the full spectrum. In general, methods from \gls{msr} have a strength in analyzing dependencies in the structure of the software artifact, but an explicit consideration of the type of work is missing. Contributions in this area focus on the users and the artifacts, mining co-evolution or co-change of project parts~\cite{zaidman2008mining,DAmbros2009} and network analysis of file dependency graph based on commit distance~\cite{Zimmermann2008,Abate2009,Weicheng2013}. Hidden work dependencies are mentioned as \emph{logical dependencies}~\cite{Oliva2011}. Also techniques for trend analysis~\cite{Ruohonen2015} and inter-dependencies between developers~\cite{lindberg2016coordinating} are proposed. However, none of these works considers the type of work being done in the process.

In the area of \gls{pm}, research gives more emphasis to the different tasks of the process. Some works focus on applying process mining for software repositories~\cite{Poncin2011a,Mittal2014,Bala2015}. In this context, approaches have been defined that use various queries to extract artifact evolution and resources~\cite{Beheshti2016,Beheshti2013}. There is research on identifying the tasks of the process by elicitation from unstructured data of user comments~\cite{Goncalves2011}. There are also process mining applications that focus on repetitive steps in software engineering, but not on singular project-oriented processes, such as \cite{Kindler2006}. All these works only consider the dependencies between work tasks to a limited extend.

%, but they lack a concept of work dependency. On the other hand, \gls{pm} contributions can help understand the work reflected by the artifacts, although to the best of our knowledge, a solution for hidden artifact dependencies is not existing yet. Moreover, \gls{pm} techniques are limited to recurrent work patterns (e.g., the process of bug fixing) and do not generally apply to the whole software project.

%In the area of \gls{msr}, many works analyze collaborative software development by mining \gls{vcs} log data.

There is also work in the area of software visualization. 
Visualization tools have been proposed in order to allow project managers to have a detailed overview of the software artifact being developed. These tools help to visually inspect artifacts similarities on different levels of granularity~\cite{Voinea2006b}, observe artifacts evolution or project members contribution~\cite{Ripley2007,Greene2015}. In general, they can be characterized as artifact-centric, and largely agnostic to the type of work being done.

%\Cref{table:related-work} summarizes how literature addresses the defined requirements. In general, methods from \gls{msr} are robust on analyzing dependencies in projects, but they lack a concept of work dependency. On the other hand, \gls{pm} contributions can help understand the work reflected by the artifacts, although to the best of our knowledge, a solution for hidden artifact dependencies is not existing yet. Moreover, \gls{pm} techniques are limited to recurrent work patterns (e.g., the process of bug fixing) and do not generally apply to the whole software project.

In the following, we develop a technique that addresses the three requirements and informs prior research on how to extract work histories and to identify the co-evolution of certain parts of a project-oriented software process.



%In this Section, we present closely related work to the approach proposed in this paper. We characterize closely related work as formal studies on providing method to extract or representing software development process. 
%
%Salameh et al. \cite{10.1109/CSIT.2016.7549475}  made a systematic review of literature to discuss Software Visualization and Evolution (SVE) tools and techniques. They analyzed 29 out of 55 papers. They concluded that the main source of information used by such tools is information extracted from software repositories. SVE tools can be classified into five different groups: graph-based, notation-based, matrix-based, metaphor-based and others. Graph-based are the most popular while notation-based are the least. SVEs focus can be either Artifact-centric visualization, Metric-centric visualization, Feature-centric visualization, or Architecture-centric visualization. The authors also identified generic functional requirements for software visualization tools: (i) views \cite{bani2016software}: show different representations; (ii) details-on demand: show more information/details; (iii) filter and search: show something conditionally; (iv) select: mark something as point of interest; (v) re-arrangement: show different arrangements of the data sets (e.g. sort, cluster, and aggregate); (vi) comparison: show the differences between different data sets.
%
%
%In \cite{Mittal:2014:PMS:2591062.2591152}, data achieved from four sources was evaluated: team wiki (used during requirement engineering), version control system (development and maintenance), issue tracking system (corrective and adaptive maintenance) and data generated as a result of constructing software by student teams in an educational setting. The main goal of the paper was to provide metrics and visualizations that better describe the work developed by the students in the discipline. From this analysis, it was possible to observe task distribution among the students in a project or commits behavior. 
%
%% Elsen \cite{DBLP:conf/vissoft/Elsen13} presents the prototype VisGi and a set of strategies for mining and displaying Git repositories. VisGi intends to abstract and visualize the branch structure of a Git, as well as its folder trees. By interpreting branches as groups of aggregated commits, their dependencies are condensed into a directed acyclic graph, and displayed using graph layout strategies. Tagging mechanisms are used to aggregate commits into compact nodes of a group graph. Sunburst diagrams are also proposed to display the content of the branches, the differences between each two branches, and the evolution of a particular selected path. Since the extraction is limited to the last commit of each group, it creates holes in older sections of most repositories. 
%
%%Greene and Fisher \cite{DBLP:conf/vissoft/Greene015} describe ConceptCloud, an interactive browser for SVN and Git repositories which combines an intuitive tag cloud visualization with an underlying concept lattice providing a formal structure for navigation. The authors claim that this solution can be used to answer questions such as \emph{What has happened in this project while I was away/?}, \emph{Which developers collaborate/?}, or \emph{What are the co-changed methods/?}. 
%
%In \cite{DBLP:conf/msr/RayNBNZ15}, Ray et al worry about improving risk analysis, recommendation and program repair techniques by automatic detecting unique changes in a software project history. They argue that unique changes require more expertise or represent code that is more complex or prone to mistakes than the more common similar (or non-unique) changes. Their contribution provides a valuable amount of information to support managers on the monitoring and managing software development processes; %however, they do not focus on visualization issues.
%
%Lehtonen et al.~\cite{DBLP:conf/ejc/LehtonenAKM16} proposed a visualization tool for collecting insights based on data collected through a tracking tool. The authors argue that analysis of this data helped the managers to understand the process more deeply showing what kind of spring lenghts and common deployment times actually exist and the identification of uncommonly long delivery times for some features. %Although the paper is related to ours in the sense that a visualization is proposed to help managers in a better decision making, in our work we focus on explicitin how the work is performed and how dependencies between artifacts combined with containments information can help understand how the development of the software can be improved.
%
%In \cite{Bala2015} a mining approach to help generate GANTT charts was proposed. They allow project managers to visualize work history from the perspective of activities performed inside a workpackage and the resource allocated to the activity.  Data from VCS logs are used for the mining and visualization. 
%
%Based on the literature proposals analyzed, we observed that solutions that deal with monitoring and managing software development process propose visualization tools that use data available from software repositories, version control systems, and IDEs [7]. Many tools have been proposed in order to support managers on the evolution of the software; They have similarities to ours, since it aims to provide insights about the project development to managers, however, they do not consider the files perspective. They do not analyses the evolution of each file over time and their relation, crossing information with structural information, like containments. Moreover, we also contribute presenting a story mining approach for automatically extracting the file evolution and provide representations of the knowledge extracted, thus facilitating the analysis of the managers, and crossing the gathered information.